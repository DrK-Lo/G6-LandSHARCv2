1-pchisq(0.3*5/0.05, df=5)
1-pchisq(0.2*5/0.05, df=5)
hist(rchisq(1000,10)*0.05/10)
hist(rchisq(1000,10)*0.05/10, xlab="FST of 10-deme island model", main="")
hist(runif(100, 0.1, 0.3))
hist(rchisq(1000,10)*0.05/10, xlab="FST of 10-deme island model", main="", breaks=seq(0,0.3,0.1))
hist(rchisq(1000,10)*0.05/10, xlab="FST of 10-deme island model", main="", breaks=seq(0,0.3,0.01))
hist(runif(100, 0.1, 0.3), breaks=seq(0,0.3,0.01))
hist(runif(100, 0.1, 0.3), breaks=seq(0,0.3,0.01), xlab="", ylab="", main=)
hist(runif(100, 0.1, 0.3), breaks=seq(0,0.3,0.01), xlab="", ylab="", main="")
hist(runif(100, 0.1, 0.3), breaks=seq(0,0.3,0.01), xlab="", ylab="", main="", col="red")
hist(rchisq(1000,10)*0.05/10, xlab="FST of 10-deme island model", main="", breaks=seq(0,0.3,0.01))
hist(rchisq(1000,10)*0.05/10, xlab="FST of 10-deme island model", main="", breaks=seq(0,0.3,0.01), col="black")
hist(runif(100, 0.1, 0.3), breaks=seq(0,0.3,0.01), xlab="", ylab="", main="")
1-pchisq(0.2*5/0.05, df=5)
1-pchisq(0.2*6.5/0.05, df=6.5)
1-pchisq(0.2*9/0.05, df=9)
1-pchisq(0.2*10/0.05, df=10)
p=0.001
p/1000
p/100
0.05/1000
0.05/10000
hist(rgamma(1000, shape=2.626, scale=0.0168))
quartz()
hist(rgamma(1000, shape=0.3815, scale=0.2835))
quartz()
hist(rchisq(1000, 5.25))
hist(rchisq(1000, 5.25)*5.25/0.05)
hist(rchisq(1000, 5.25)*0.05/5.25)
hist(rchisq(10000, 5.25)*0.05/5.25, breaks=seq(0,0.4, 0.01))
hist(rchisq(10000, 5.25, ncp=1)*0.05/5.25, breaks=seq(0,0.4, 0.01))
hist(rchisq(10000, 5.25, ncp=.11)*0.05/5.25, breaks=seq(0,0.4, 0.01))
hist(rchisq(10000, 5.25, ncp=.011)*0.05/5.25, breaks=seq(0,0.4, 0.01))
hist(rchisq(10000, 5.25, ncp=1000)*0.05/5.25, breaks=seq(0,0.4, 0.01))
hist(rchisq(10000, 5.25, ncp=10)*0.05/5.25, breaks=seq(0,0.4, 0.01))
hist(rchisq(10000, 5.25)*0.05/5.25, breaks=seq(0,0.4, 0.01))
hist(rchisq(10000, 5.25, ncp=0.00001)*0.05/5.25, breaks=seq(0,0.4, 0.01))
hist(rchisq(10000, 5.25, ncp=0.00000000001)*0.05/5.25, breaks=seq(0,0.4, 0.01))
hist(rchisq(10000, 5.25, ncp=1)*0.05/5.25, breaks=seq(0,0.4, 0.01))
hist(rgamma(10000, shape=2.626, scale=0.0168), breaks=seq(0,0.4, 0.01))
2.626*0.0168
max(rchisq(10000, 5.25, ncp=1)*0.05/5.25)
max(rgamma(10000, shape=2.626, scale=0.0168)
)
max(rgamma(10000, shape=2.626, scale=0.0168))
K=100
rbar=-0.01
s <- 2*rbar
k=ln(K)
k=log(K)
T=K/(s*rbar)*(1-(1+sk)/exp(sk))
T=K/(s*rbar)*(1-(1+s*k)/exp(s*k))
T
rbar=0.01; s <- 2*rbar; T=K/(s*rbar)*(1-(1+s*k)/exp(s*k))
T
rbar=0.01; s <- 2*rbar; T=K/(s*rbar)*(1-(1+s*k)/exp(s*k)); T
rbar=-1; s <- 2*rbar; T=K/(s*rbar)*(1-(1+s*k)/exp(s*k))
T
rbar=1; s <- 2*rbar; T=K/(s*rbar)*(1-(1+s*k)/exp(s*k))
T
demogparams <- read.table(DemogMetaFile, header=F)
library(gtools)
rdirichlet(10, c(0.1,0.2))
rdirichlet(10, c(0.5,0.5))
rdirichlet(10, c(0.3,0.3, 0.4))
rdirichlet(10, c(1,1,1))
x<-rdirichlet(10, c(1,1,1))
 ddirichlet(x, c(1,1,1) )
x<-rdirichlet(10, c(0.3,0.3,0.4))
 ddirichlet(x, c(1,1,1) )
 ddirichlet(x, c(1,1,2) )
x<-rdirichlet(10, c(0.3,0.3,2))
 ddirichlet(x, c(1,1,2) )
 ddirichlet(x, c(1,1,1) )
 rdirichlet(10, c(1,1,1) )
rbeta(10, 1,1)
rbeta(10, c(1,1))
rbeta(10, 1,1)
rbeta(1000, 1,1)
hist(rbeta(1000, 1,1))
hist(rdirichlet(10, c(1,1,1)[,1])
)
hist(rdirichlet(10, c(1,1,1))[,1])
hist(rdirichlet(1000, c(1,1,1))[,1])
hist(rdirichlet(1000, c(1,1,1))[,2])
hist(rdirichlet(1000, c(1,1,1))[,3])
hist(rdirichlet(1000, c(1,1,1))[,3]+rdirichlet(1000, c(1,1,1))[,2])
hist(rdirichlet(1000, c(1,1,1))[,3]+rdirichlet(1000, c(1,1,1))[,2]+ rdirichlet(1000, c(1,1,1))[,1])
rowSums(rdirichlet(1000, c(1,1,1)))
rdirichlet(1000, c(1,1,1))[,3]+rdirichlet(1000, c(1,1,1))[,2]+ rdirichlet(1000, c(1,1,1))[,1]
x <- rdirichlet(1000,c(1,1,1))
hist(x[,1]+x[,2])
hist(x[,2]+x[,3])
hist(x[,2])
x <- rbeta(1000, 1,1)
hist((x*(1-x))
)
hist((x*(1-x)))
x <- rbeta(1000, 0.5,1); hist(x*(1-x))
x <- rbeta(1000, 1,1.5); hist(x*(1-x))
x <- rbeta(1000, 1,2); hist(x*(1-x))
x <- rbeta(1000, 1,20); hist(x*(1-x))
x <- rbeta(1000, 1,10); hist(x*(1-x))
x <- rbeta(1000, 10,1); hist(x*(1-x))
x <- rbeta(1000, 1,1); hist(x*(1-x))
x <- rbeta(1000, 0.1,1); hist(x*(1-x))
x <- rbeta(1000, 1,0.1); hist(x*(1-x))
x <- rbeta(1000, 10,10); hist(x*(1-x))
x <- rbeta(1000, 100,100); hist(x*(1-x))
x <- rbeta(1000, 100,10); hist(x*(1-x))
x <- rbeta(1000, 15,10); hist(x*(1-x))
x <- rbeta(1000, 15,10); hist(x)
x <- rbeta(1000, 1,10); hist(x)
x <- rbeta(1000, 1,2); hist(x)
x <- rbeta(1000, 0.1,0.1); hist(x)
x <- rbeta(1000, 0.1,0); hist(x)
x <- rbeta(1000, 0.1,1); hist(x)
x <- rbeta(1000, 0.5,1); hist(x)
x <- rbeta(1000, 0.5,10); hist(x)
persp(neut,sel, R.FDR)
#
neut <- c(rep(800,5), 200, 400, 800, 1600)#
#
sel<- c(20,50, 100, 200, 400, rep(100,4))#
#
f_pos <- c(rep(15,5), 3, 7, 15, 30)#
#
t_pos <- c(12, 30, 61, 122, 244, rep(61,4))#
#
R.FDR <- t_pos/(t_pos+f_pos)#
#
persp(neut,sel, R.FDR)
contour(neut,sel, R.FDR)
neut <- c(rep(800,5), 200, 400, 800, 1600)
#
neut <- c( 200, 400, rep(800,5), 1600)#
#
sel<- c(20,50,  rep(100,4), 200, 400)#
#
f_pos <- c( 3, 7, rep(15,5), 30)#
#
t_pos <- c(12, 30, rep(61,4) 122, 244)#
#
R.FDR <- t_pos/(t_pos+f_pos)#
#
contour(neut,sel, R.FDR)
?contour
#
neut_base <- 800#
f_pos_base <- 15#
#
sel_base <- 100#
t_pos_base <- 61#
#
factors <- c(1/5, 1/2, 1, 2, 4, 6)#
#
neut_factors <- neut_base*factors#
sel_factors <- sel_base*factors#
f_pos_factors <- f_pos_base*factors#
t_pos_factors <- t_pos_base*factors
t_pos_factors
i=1
t_pos_factors/(f_pos_base[i]+t_pos_factors)
f_pos_factors
	yo[i,] <- f_pos_base[i]/(f_pos_base[i]+t_pos_factors)
f_pos_base[i]/(f_pos_base[i]+t_pos_factors)
f_pos_factors
3/(3+366)
i
f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)
#
for (i in 1:length(neut_factors)){#
	yo[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
}
#
yo <- matrix(NA, nrow=neut_factors, ncol=sel_factors)#
#
for (i in 1:length(neut_factors)){#
	yo[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
}
#
yo <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
#
for (i in 1:length(neut_factors)){#
	yo[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
}
R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
#
for (i in 1:length(neut_factors)){#
	R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
}#
#
contour(neut,sel, R.FDR)
R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
#
for (i in 1:length(neut_factors)){#
	R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
}#
#
contour(neut_factors,sel_factors, R.FDR)
contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci")
persp(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci")
#
neut_base <- 800#
f_pos_base <- 15#
#
sel_base <- 100#
t_pos_base <- 61#
#
factors <- c(1/5, 1/2, 1, 2, 4, 6, 12, 20)#
#
neut_factors <- neut_base*factors#
sel_factors <- sel_base*factors#
f_pos_factors <- f_pos_base*factors#
t_pos_factors <- t_pos_base*factors#
#
R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
#
for (i in 1:length(neut_factors)){#
	R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
}#
#
persp(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci")
#
#
neut_base <- 800#
f_pos_base <- 15#
#
sel_base <- 100#
t_pos_base <- 61#
#
factors <- c(1/5, 1/2, 1, 2, 4, 6, 10)#
#
neut_factors <- neut_base*factors#
sel_factors <- sel_base*factors#
f_pos_factors <- f_pos_base*factors#
t_pos_factors <- t_pos_base*factors#
#
R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
#
for (i in 1:length(neut_factors)){#
	R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
}#
#
persp(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci")
?persp
persp(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", theta=90)
persp(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", theta=45)
persp(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", theta=-45)
persp(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", theta=-15)
persp(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", theta=-45)
persp(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", theta=-75)
persp(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", theta=-65)
contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci")
?contour
contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.8))
contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9))
contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), cex=2)
contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("ariel", "Large"))
, vfont=c("ariel", "Large")
contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9))
15/61
contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.01, 0.05, 0.1, 0.25, 0.3, 0.5, 0.7, 0.9))
contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.01, 0.05, 0.1, 0.3, 0.3, 0.5, 0.7, 0.9))
contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9))
#
neut_base <- 800#
f_pos_base <- 1#
#
sel_base <- 100#
t_pos_base <- 61#
#
factors <- c(1/5, 1/2, 1, 2, 4, 6, 10)#
#
neut_factors <- neut_base*factors#
sel_factors <- sel_base*factors#
f_pos_factors <- f_pos_base*factors#
t_pos_factors <- t_pos_base*factors#
#
R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
#
for (i in 1:length(neut_factors)){#
	R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
}#
#
contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9))
t_pos_base <- 91
#
neut_base <- 800#
f_pos_base <- 15#
#
sel_base <- 100#
t_pos_base <- 91#
#
factors <- c(1/5, 1/2, 1, 2, 4, 6, 10)#
#
neut_factors <- neut_base*factors#
sel_factors <- sel_base*factors#
f_pos_factors <- f_pos_base*factors#
t_pos_factors <- t_pos_base*factors#
#
R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
#
for (i in 1:length(neut_factors)){#
	R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
}#
#
contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9))
#
#
neut_base <- 800#
f_pos_base <- 15#
#
sel_base <- 100#
t_pos_base <- 100#
#
factors <- c(1/5, 1/2, 1, 2, 4, 6, 10)#
#
neut_factors <- neut_base*factors#
sel_factors <- sel_base*factors#
f_pos_factors <- f_pos_base*factors#
t_pos_factors <- t_pos_base*factors#
#
R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
#
for (i in 1:length(neut_factors)){#
	R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
}#
#
contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9))
#
neut_base <- 800#
f_pos_base <- 1#
#
sel_base <- 100#
t_pos_base <- 100#
#
factors <- c(1/5, 1/2, 1, 2, 4, 6, 10)#
#
neut_factors <- neut_base*factors#
sel_factors <- sel_base*factors#
f_pos_factors <- f_pos_base*factors#
t_pos_factors <- t_pos_base*factors#
#
R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
#
for (i in 1:length(neut_factors)){#
	R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
}#
#
contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9))
#
#
neut_base <- 800#
f_pos_base <- 1#
#
sel_base <- 100#
t_pos_base <- 100#
	#
	#
		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2, 4, 6, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9))
#
neut_base <- 800#
f_pos_base <- 1#
#
sel_base <- 100#
t_pos_base <- 100#
	#
	#
		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2, 4, 6, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9))
#
neut_base <- 800#
f_pos_base <- 15#
#
sel_base <- 100#
t_pos_base <- 100#
	#
	#
		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2, 4, 6, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9))
#
neut_base <- 800#
f_pos_base <- 15#
#
sel_base <- 100#
t_pos_base <- 100#
	#
	#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2, 4, 6, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9))#
		}
		FPR <-  paste("Base FPR:", f_pos_base/neut_base, "for",neut_base,"neutral loci", sep=" ")
		TPR <- paste("Base TPR:", t_pos_base/sel_base, "for", sel_base, "selected loci", sep=" ")
		main(paste(FPR, "/n", TPR))
?contour
FPR <-  paste("Base FPR:", f_pos_base/neut_base, "for",neut_base,"neutral loci", sep=" ")#
		TPR <- paste("Base TPR:", t_pos_base/sel_base, "for", sel_base, "selected loci", sep=" ")#
		main <- (paste(FPR, "/n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), title=main)
		title(main)
		main <- (paste(FPR, "\n", TPR))
		title(main)
#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2, 4, 6, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", f_pos_base/neut_base, "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", t_pos_base/sel_base, "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9))#
		title(main)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(3,3,3,1))#
#
MakeFDRPlot(800, 15, 100, 61)#
MakeFDRPlot(800, 1, 100, 61)#
MakeFDRPlot(800, 15, 100, 100)#
MakeFDRPlot(800, 1, 100, 100)
#
par(mfrow=c(2,2), mar=c(3,3,3,1), width=6, height=6)#
#
MakeFDRPlot(800, 15, 100, 61)#
MakeFDRPlot(800, 1, 100, 61)#
MakeFDRPlot(800, 15, 100, 100)#
MakeFDRPlot(800, 1, 100, 100)
?par
#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2, 4, 6, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9))#
		title(main)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(3,3,3,1), width=6, height=6)#
#
MakeFDRPlot(800, 15, 100, 61)#
MakeFDRPlot(800, 1, 100, 61)#
MakeFDRPlot(800, 15, 100, 100)#
MakeFDRPlot(800, 1, 100, 100)
#
	#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2, 4, 6, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9),cex.lab=3)#
		title(main)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(3,3,3,1), width=6, height=6)#
#
MakeFDRPlot(800, 15, 100, 61)#
MakeFDRPlot(800, 1, 100, 61)#
MakeFDRPlot(800, 15, 100, 100)#
MakeFDRPlot(800, 1, 100, 100)
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9),cex.text=3)
?contour
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9),vfont=c("times","bold"))
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), fontface="bold")
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("san serif","bold")
)
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold")
)
#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2, 4, 6, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold")#
		title(main)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(3,3,3,1), width=6, height=6)#
#
MakeFDRPlot(800, 15, 100, 61)#
MakeFDRPlot(800, 7, 100, 61)#
MakeFDRPlot(800, 15, 100, 100)#
MakeFDRPlot(800, 1, 100, 100)
#
	#
	#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2, 4, 6, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"))#
		title(main)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(3,3,3,1), width=6, height=6)#
#
MakeFDRPlot(800, 15, 100, 61)#
MakeFDRPlot(800, 7, 100, 61)#
MakeFDRPlot(800, 15, 100, 100)#
MakeFDRPlot(800, 1, 100, 100)
#
	#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2, 4, 6, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"))#
		title(main)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4), width=6, height=6)#
#
MakeFDRPlot(800, 15, 100, 61)#
MakeFDRPlot(800, 7, 100, 61)#
MakeFDRPlot(800, 15, 100, 100)#
MakeFDRPlot(800, 1, 100, 100)
#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2, 4, 6, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100,1), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100,1), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"))#
		title(main)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4), width=6, height=6)#
#
MakeFDRPlot(800, 15, 100, 61)#
MakeFDRPlot(800, 7, 100, 61)#
MakeFDRPlot(800, 15, 100, 100)#
MakeFDRPlot(800, 1, 100, 100)
#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2, 4, 6, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100,1), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100,1), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"))#
		title(main)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4), width=6, height=6)#
#
MakeFDRPlot(800, 15, 100, 61)#
MakeFDRPlot(800, 1, 100, 61)#
MakeFDRPlot(800, 15, 100, 100)#
MakeFDRPlot(800, 1, 100, 100)
#
	#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2, 4, 6, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100,1), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100,1), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"))#
		title(main)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4), width=6, height=6)#
#
MakeFDRPlot(800, 15, 100, 61)#
MakeFDRPlot(800, 1, 100, 61)#
MakeFDRPlot(800, 15, 100, 100)#
MakeFDRPlot(800, 1, 40, 100)
#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2, 4, 6, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100,1), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100,1), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"))#
		title(main)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4), width=6, height=6)#
#
MakeFDRPlot(800, 15, 100, 61)#
MakeFDRPlot(800, 1, 100, 61)#
MakeFDRPlot(800, 15, 100, 100)#
MakeFDRPlot(800, 1, 100, 40)
#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2, 4, 6, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100,1), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100,1), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"))#
		title(main)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4), width=6, height=6)#
#
MakeFDRPlot(800, 15, 100, 61)#
MakeFDRPlot(800, 1, 100, 61)#
MakeFDRPlot(800, 15, 100, 100)#
MakeFDRPlot(800, 1, 100, 30)
#
MakeFDRPlot(800, 15, 100, 61)#
MakeFDRPlot(800, 15, 100, 100)#
MakeFDRPlot(800, 1, 100, 61)#
MakeFDRPlot(800, 1, 100, 40)
#
MakeFDRPlot(1000, 15, 100, 61)#
MakeFDRPlot(1000, 15, 100, 100)#
MakeFDRPlot(1000, 1, 100, 61)#
MakeFDRPlot(1000, 1, 100, 40)
#
	#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2,3, 4,5, 6,7,8,9, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100,1), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100,1), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"))#
		title(main)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4), width=6, height=6)#
#
MakeFDRPlot(1000, 15, 100, 61)#
MakeFDRPlot(1000, 15, 100, 100)#
MakeFDRPlot(1000, 1, 100, 61)#
MakeFDRPlot(1000, 1, 100, 40)
#
	#
	#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base, textlab){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2,3, 4,5, 6,7,8,9, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100,1), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100,1), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"))#
		title(main)#
		text(10000,1000, textlab)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4))#
		#
		MakeFDRPlot(1000, 15, 100, 61,"A")#
		MakeFDRPlot(1000, 15, 100, 100, "B")#
		MakeFDRPlot(1000, 1, 100, 61,"C")#
		MakeFDRPlot(1000, 1, 100, 40, "D")
#
	#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base, textlab){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2,3, 4,5, 6,7,8,9, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100,1), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100,1), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"))#
		title(main)#
		text(9500,950, textlab, cex=2)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4))#
		#
		MakeFDRPlot(1000, 15, 100, 61,"A")#
		MakeFDRPlot(1000, 15, 100, 100, "B")#
		MakeFDRPlot(1000, 1, 100, 61,"C")#
		MakeFDRPlot(1000, 1, 100, 40, "D")
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold", size=2))
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold", size=20))
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("Helvetica","bold")
)
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("Helvetica","bold"))
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("Vf","bold"))
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c(Vf,"bold"))
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("Times","bold"))
#
	#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base, textlab){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2,3, 4,5, 6,7,8,9, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100,1), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100,1), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"), labcex=2)#
		title(main)#
		text(9500,950, textlab, cex=2)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4))#
		#
		MakeFDRPlot(1000, 15, 100, 61,"A")#
		MakeFDRPlot(1000, 15, 100, 100, "B")#
		MakeFDRPlot(1000, 1, 100, 61,"C")#
		MakeFDRPlot(1000, 1, 100, 40, "D")
#
	#
	#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base, textlab){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2,3, 4,5, 6,7,8,9, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100,1), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100,1), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"), labcex=1.2)#
		title(main)#
		text(9500,950, textlab, cex=2)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4))#
		#
		MakeFDRPlot(1000, 15, 100, 61,"A")#
		MakeFDRPlot(1000, 15, 100, 100, "B")#
		MakeFDRPlot(1000, 1, 100, 61,"C")#
		MakeFDRPlot(1000, 1, 100, 40, "D")
#
	#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base, textlab){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2,3, 4,5, 6,7,8,9, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100,1), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100,1), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"), labcex=1)#
		title(main)#
		text(9500,950, textlab, cex=2)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4))#
		#
		MakeFDRPlot(1000, 15, 100, 61,"A")#
		MakeFDRPlot(1000, 15, 100, 100, "B")#
		MakeFDRPlot(1000, 1, 100, 61,"C")#
		MakeFDRPlot(1000, 1, 100, 40, "D")
#
	#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base, textlab){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2,3, 4,5, 6,7,8,9, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100,1), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100,1), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"), labcex=0.8)#
		title(main)#
		text(9500,950, textlab, cex=2)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4))#
		#
		MakeFDRPlot(1000, 15, 100, 61,"A")#
		MakeFDRPlot(1000, 15, 100, 100, "B")#
		MakeFDRPlot(1000, 1, 100, 61,"C")#
		MakeFDRPlot(1000, 1, 100, 40, "D")
#
	#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base, textlab){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2,3, 4,5, 6,7,8,9, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100,1), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100,1), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"), labcex=0.8)#
		title(main)#
		text(9500,950, textlab, cex=2)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4))#
		#
		MakeFDRPlot(1000, 15, 100, 61,"A")#
		MakeFDRPlot(1000, 15, 100, 100, "B")#
		MakeFDRPlot(1000, 1, 100, 61,"C")#
		MakeFDRPlot(1000, 1, 100, 30, "D")
15/1000
30/2000
61/200
61/100
#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base, textlab){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2,3, 4,5, 6,7,8,9, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100,1), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100,1), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"), labcex=0.8)#
		abline(1/10, col="grey")#
		title(main)#
		text(9500,950, textlab, cex=2)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4))#
		#
		MakeFDRPlot(1000, 15, 100, 61,"A")#
		MakeFDRPlot(1000, 15, 100, 100, "B")#
		MakeFDRPlot(1000, 1, 100, 61,"C")#
		MakeFDRPlot(1000, 1, 100, 30, "D")
#
	#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base, textlab){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2,3, 4,5, 6,7,8,9, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100,1), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100,1), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"), labcex=0.8)#
		abline(1/10,0, col="grey")#
		title(main)#
		text(9500,950, textlab, cex=2)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4))#
		#
		MakeFDRPlot(1000, 15, 100, 61,"A")#
		MakeFDRPlot(1000, 15, 100, 100, "B")#
		MakeFDRPlot(1000, 1, 100, 61,"C")#
		MakeFDRPlot(1000, 1, 100, 30, "D")
#
	#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base, textlab){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2,3, 4,5, 6,7,8,9, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100,1), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100,1), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"), labcex=0.8)#
		abline(0,1/10, col="grey")#
		title(main)#
		text(9500,950, textlab, cex=2)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4))#
		#
		MakeFDRPlot(1000, 15, 100, 61,"A")#
		MakeFDRPlot(1000, 15, 100, 100, "B")#
		MakeFDRPlot(1000, 1, 100, 61,"C")#
		MakeFDRPlot(1000, 1, 100, 30, "D")#
		#
#When the FPR is "high", 1.5% in this case, For a large number of neutral loci, as the number of selected loci in the tests were increased, the percentage of false positives in your results decreases very slowly.  However, when the false positive rate is much smaller, at a large number of netural loci, as the number of selected loci in the tests increases, the percentage of false positives in your results decreases. This rate is not directly related to the ratio of selected to neutral loci.#
#When the FPR is "low" (1/1000), #
#
#Solution 1: Test only candidate loci#
#Solution 2: Use stricter corrections for multiple tests#
#Does this mean we should only be testing candidate loci for selection?		#
#classic case of what came first, chicken or egg#
#Sampling design --- use randomly sampled genomic data to determine distribution of neutral loci
#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base, textlab){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2,3, 4,5, 6,7,8,9, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100,1), "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100,1), "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"), labcex=0.8)#
		abline(0,1/10, col="lightgrey")#
		title(main)#
		text(9500,950, textlab, cex=2)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4))#
		#
		MakeFDRPlot(1000, 15, 100, 61,"A")#
		MakeFDRPlot(1000, 15, 100, 100, "B")#
		MakeFDRPlot(1000, 1, 100, 61,"C")#
		MakeFDRPlot(1000, 1, 100, 30, "D")#
		#
#When the FPR is "high", 1.5% in this case, For a large number of neutral loci, as the number of selected loci in the tests were increased, the percentage of false positives in your results decreases very slowly.  However, when the false positive rate is much smaller, at a large number of netural loci, as the number of selected loci in the tests increases, the percentage of false positives in your results decreases. This rate is not directly related to the ratio of selected to neutral loci.#
#When the FPR is "low" (1/1000), #
#
#Solution 1: Test only candidate loci#
#Solution 2: Use stricter corrections for multiple tests#
#Does this mean we should only be testing candidate loci for selection?		#
#classic case of what came first, chicken or egg#
#Sampling design --- use randomly sampled genomic data to determine distribution of neutral loci
#
	#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base, textlab){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2,3, 4,5, 6,7,8,9, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100,1))# "% for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100,1))#, "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"), labcex=0.8)#
		abline(0,1/10, col="lightgrey")#
		title(main)#
		text(9500,950, textlab, cex=2)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4))#
		#
		MakeFDRPlot(1000, 15, 100, 61,"A")#
		MakeFDRPlot(1000, 15, 100, 100, "B")#
		MakeFDRPlot(1000, 1, 100, 61,"C")#
		MakeFDRPlot(1000, 1, 100, 30, "D")#
		#
#When the FPR is "high", 1.5% in this case, For a large number of neutral loci, as the number of selected loci in the tests were increased, the percentage of false positives in your results decreases very slowly.  However, when the false positive rate is much smaller, at a large number of netural loci, as the number of selected loci in the tests increases, the percentage of false positives in your results decreases. #
#The light grey line indicates a 1/10 ratio of selected to neutral loci, and shows that most of the time, the ratio of selected to neutral loci does not determine the percentage of false positives in your results (although they are closely related). This occurs because the false positive rate is typically much lower than the true positive rate.#
#
#When the FPR is "low" (1/1000), #
#
#Solution 1: Test only candidate loci#
#Solution 2: Use stricter corrections for multiple tests#
#Does this mean we should only be testing candidate loci for selection?		#
#classic case of what came first, chicken or egg#
#Sampling design --- use randomly sampled genomic data to determine distribution of neutral loci
#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base, textlab){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2,3, 4,5, 6,7,8,9, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100,1) "%")# for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100,1)"%")# "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"), labcex=0.8)#
		abline(0,1/10, col="lightgrey")#
		title(main)#
		text(9500,950, textlab, cex=2)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4))#
		#
		MakeFDRPlot(1000, 15, 100, 61,"A")#
		MakeFDRPlot(1000, 15, 100, 100, "B")#
		MakeFDRPlot(1000, 1, 100, 61,"C")#
		MakeFDRPlot(1000, 1, 100, 30, "D")#
		#
#When the FPR is "high", 1.5% in this case, For a large number of neutral loci, as the number of selected loci in the tests were increased, the percentage of false positives in your results decreases very slowly.  However, when the false positive rate is much smaller, at a large number of netural loci, as the number of selected loci in the tests increases, the percentage of false positives in your results decreases. #
#The light grey line indicates a 1/10 ratio of selected to neutral loci, and shows that most of the time, the ratio of selected to neutral loci does not determine the percentage of false positives in your results (although they are closely related). This occurs because the false positive rate is typically much lower than the true positive rate.#
#
#When the FPR is "low" (1/1000), #
#
#Solution 1: Test only candidate loci#
#Solution 2: Use stricter corrections for multiple tests#
#Does this mean we should only be testing candidate loci for selection?		#
#classic case of what came first, chicken or egg#
#Sampling design --- use randomly sampled genomic data to determine distribution of neutral loci
#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base, textlab){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2,3, 4,5, 6,7,8,9, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base FPR: ", round(f_pos_base/neut_base*100,1) ,"%")# for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base TPR: ", round(t_pos_base/sel_base*100,1),"%")# "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"), labcex=0.8)#
		abline(0,1/10, col="lightgrey")#
		title(main)#
		text(9500,950, textlab, cex=2)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4))#
		#
		MakeFDRPlot(1000, 15, 100, 61,"A")#
		MakeFDRPlot(1000, 15, 100, 100, "B")#
		MakeFDRPlot(1000, 1, 100, 61,"C")#
		MakeFDRPlot(1000, 1, 100, 30, "D")#
		#
#When the FPR is "high", 1.5% in this case, For a large number of neutral loci, as the number of selected loci in the tests were increased, the percentage of false positives in your results decreases very slowly.  However, when the false positive rate is much smaller, at a large number of netural loci, as the number of selected loci in the tests increases, the percentage of false positives in your results decreases. #
#The light grey line indicates a 1/10 ratio of selected to neutral loci, and shows that most of the time, the ratio of selected to neutral loci does not determine the percentage of false positives in your results (although they are closely related). This occurs because the false positive rate is typically much lower than the true positive rate.#
#
#When the FPR is "low" (1/1000), #
#
#Solution 1: Test only candidate loci#
#Solution 2: Use stricter corrections for multiple tests#
#Does this mean we should only be testing candidate loci for selection?		#
#classic case of what came first, chicken or egg#
#Sampling design --- use randomly sampled genomic data to determine distribution of neutral loci
#
#
#
#
#
	#
	#
MakeFDRPlot<- function(neut_base, f_pos_base, sel_base, t_pos_base, textlab){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2,3, 4,5, 6,7,8,9, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base False Pos. Rate: ", round(f_pos_base/neut_base*100,1) ,"%")# for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base True Pos. Rate: ", round(t_pos_base/sel_base*100,1),"%")# "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"), labcex=0.8)#
		abline(0,1/10, col="lightgrey")#
		title(main)#
		text(9500,950, textlab, cex=2)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4))#
		#
		MakeFDRPlot(1000, 15, 100, 61,"A")#
		MakeFDRPlot(1000, 15, 100, 100, "B")#
		MakeFDRPlot(1000, 1, 100, 61,"C")#
		MakeFDRPlot(1000, 1, 100, 30, "D")#
		#
#When the FPR is "high", 1.5% in this case, For a large number of neutral loci, as the number of selected loci in the tests were increased, the percentage of false positives in your results decreases very slowly.  However, when the false positive rate is much smaller, at a large number of netural loci, as the number of selected loci in the tests increases, the percentage of false positives in your results decreases. #
#The light grey line indicates a 1/10 ratio of selected to neutral loci, and shows that most of the time, the ratio of selected to neutral loci does not determine the percentage of false positives in your results (although they are closely related). This occurs because the false positive rate is typically much lower than the true positive rate.#
#
#When the FPR is "low" (1/1000), #
#
#Solution 1: Test only candidate loci#
#Solution 2: Use stricter corrections for multiple tests#
#Does this mean we should only be testing candidate loci for selection?		#
#classic case of what came first, chicken or egg#
#Sampling design --- use randomly sampled genomic data to determine distribution of neutral loci
#
#
#
## KE Lotterhos#
## Oct 2012#
## Make proportion false positive plot. Given number of neutral or "no effect" tests (neut_base), #
## the number of those tests that are (Falsely) significant by the method (f_pos_base), a number of selected or "true effect" tests, and#
## the number of those tests that are significant by the methods (t_pos_base).  The base number of tests in each category #
## ("no effect" vs "true effect") will be multiplied by factors ranging from 1/5 to 10 to make a contour plot of the proportion #
## of false positives out of all positive tests.#
	#
	#
MakePFP_Plot<- function(neut_base, f_pos_base, sel_base, t_pos_base, textlab){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2,3, 4,5, 6,7,8,9, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base False Pos. Rate: ", round(f_pos_base/neut_base*100,1) ,"%")# for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base True Pos. Rate: ", round(t_pos_base/sel_base*100,1),"%")# "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"), labcex=0.8)#
		abline(0,1/10, col="lightgrey")#
		title(main)#
		text(9500,950, textlab, cex=2)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4), bg="white")#
		#
		MakePFP_Plot(1000, 15, 100, 61,"A")#
		MakePFP_Plot(1000, 15, 100, 100, "B")#
		MakePFP_Plot(1000, 1, 100, 61,"C")#
		MakePFP_Plot(1000, 1, 100, 30, "D")#
		#
#When the FPR is "high", 1.5% in this case, For a large number of neutral loci, as the number of selected loci in the tests were increased, the percentage of false positives in your results decreases very slowly.  However, when the false positive rate is much smaller, at a large number of netural loci, as the number of selected loci in the tests increases, the percentage of false positives in your results decreases. #
#The light grey line indicates a 1/10 ratio of selected to neutral loci, and shows that most of the time, the ratio of selected to neutral loci does not determine the percentage of false positives in your results (although they are closely related). This occurs because the false positive rate is typically much lower than the true positive rate.#
#
#When the FPR is "low" (1/1000), #
#
#Solution 1: Test only candidate loci#
#Solution 2: Use stricter corrections for multiple tests#
#Does this mean we should only be testing candidate loci for selection?		#
#classic case of what came first, chicken or egg#
#Sampling design --- use randomly sampled genomic data to determine distribution of neutral loci#
#candidate loci should be candidates because of some other reason (i.e. not because they were significant in another test)#
#focus on false positive reduction---strict bonferroni corrections can decrease false positives
#
#
#
## KE Lotterhos#
## Oct 2012#
## Make proportion false positive plot. Given number of neutral or "no effect" tests (neut_base), #
## the number of those tests that are (Falsely) significant by the method (f_pos_base), a number of selected or "true effect" tests, and#
## the number of those tests that are significant by the methods (t_pos_base).  The base number of tests in each category #
## ("no effect" vs "true effect") will be multiplied by factors ranging from 1/5 to 10 to make a contour plot of the proportion #
## of false positives out of all positive tests.#
	#
	#
MakePFP_Plot<- function(neut_base, f_pos_base, sel_base, t_pos_base, textlab){		#
		factors <- c(1/5, 1/4,1/3, 1/2, 1, 2,3, 4,5, 6,7,8,9, 10)#
		#
		neut_factors <- neut_base*factors#
		sel_factors <- sel_base*factors#
		f_pos_factors <- f_pos_base*factors#
		t_pos_factors <- t_pos_base*factors#
		#
		R.FDR <- matrix(NA, nrow=length(neut_factors), ncol=length(sel_factors))#
		#
		for (i in 1:length(neut_factors)){#
			R.FDR[i,] <- f_pos_factors[i]/(f_pos_factors[i]+t_pos_factors)#
		}#
		FPR <-  paste("Base False Pos. Rate: ", round(f_pos_base/neut_base*100,1) ,"%")# for ",neut_base," neutral loci", sep="")#
		TPR <- paste("Base True Pos. Rate: ", round(t_pos_base/sel_base*100,1),"%")# "% for ", sel_base, " selected loci", sep="")#
		main <- (paste(FPR, "\n", TPR))#
		#
		contour(neut_factors,sel_factors, R.FDR, xlab="Number Neutral Loci", ylab="Number Selected Loci", levels=c(0.001, 0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9), vfont=c("sans serif","bold"), labcex=0.8)#
		abline(0,1/10, col="lightgrey")#
		title(main)#
		text(9500,950, textlab, cex=2)#
		#
		}#
		#
	#
neut_base <- 800; f_pos_base <- 15#
sel_base <- 100; t_pos_base <- 100	#
#
par(mfrow=c(2,2), mar=c(4,4,4,4), bg="white")#
		#
		MakePFP_Plot(1000, 15, 100, 61,"A")#
		MakePFP_Plot(1000, 15, 100, 100, "B")#
		MakePFP_Plot(1000, 1, 100, 61,"C")#
		MakePFP_Plot(1000, 1, 100, 30, "D")#
		#
#When the FPR is "high", 1.5% in this case, For a large number of neutral loci, as the number of selected loci in the tests were increased, the percentage of false positives in your results decreases very slowly.  However, when the false positive rate is much smaller, at a large number of netural loci, as the number of selected loci in the tests increases, the percentage of false positives in your results decreases. #
#The light grey line indicates a 1/10 ratio of selected to neutral loci, and shows that most of the time, the ratio of selected to neutral loci does not determine the percentage of false positives in your results (although they are closely related). This occurs because the false positive rate is typically much lower than the true positive rate.#
#
#When the FPR is "low" (1/1000), #
#
#Solution 1: Test only candidate loci#
#Solution 2: Use stricter corrections for multiple tests#
#Does this mean we should only be testing candidate loci for selection?		#
#classic case of what came first, chicken or egg#
#Sampling design --- use randomly sampled genomic data to determine distribution of neutral loci#
#candidate loci should be candidates because of some other reason (i.e. not because they were significant in another test)#
#focus on false positive reduction---strict bonferroni corrections can decrease false positives
mulitnomDrift <- function(x11, x12, x21, x22, N){return(rmultinom(1,N, c(x11, x12,x21,x22))/N)}
multinomDrift(0.25,0.25, 0.25, 0.25, 0)
multinomDrift(0.25,0.25, 0.25, 0.25, 0)
multinomDrift <- function(x11, x12, x21, x22, N){return(rmultinom(1,N, c(x11, x12,x21,x22))/N)}
multinomDrift(0.25,0.25, 0.25, 0.25, 0)
CodeDir <- "/Users/katie/Dropbox/MetapopWestgrid/MetapopCodeWestgrid"
source("Code_AllSourceFiles.R")
CodeDir <- "/Users/katie/Dropbox/MetapopWestgrid/MetapopCodeWestgrid"
setwd(CodeDir)
source("Code_AllSourceFiles.R")
#
#
IBDSel_Demog <- function(DemogFile, START_GEN, GEN, r, K_cell, u, MOVIE, CodeDir, headDir, subfolder, ResultsFSTFile, ENVI_ID, ENVI_DIR, s_low, s_high, t_low, t_high, recomb, RefugiaSelection){#
	 #
	#	The Demog File has info on the starting locations of the population(s)#
	#	START_GEN = number of generations to loop through before population expansion#
	#	GEN = number of generations to loop through for population growth#
	#  r = growth rate#
	# K_cell = Carrying Capacity in each cell, K_cell = 43 will give ~1e07 individuals on a 360 * 360 landscape#
	# u = mutation rate#
	# MOVIE = TRUE, print out an image every 50 generations#
#
	#CodeDir <- ("~/Dropbox/MetapopCode") #other comps#
	#CodeDir <- "/home/klott/MetapopCode" # ROGUE#
	#setwd(CodeDir) #
	#headDir <- ("/home/klott/MetapopResults") # ROGUE#
		#
	  startT <- tic()#
#
	runname <- getRunName() #
#  subfolder <- "/NeutralLandscapesDemog"#
    #
    if (file.exists(paste(headDir, subfolder, sep=""))){}else{dir.create(paste(headDir, subfolder, sep=""))}#
	#
		#
	##########################################
	# Determine scaling for population based on dispersal kernel#
	# SD is sigma or the standard deviation of the dispersal kernel#
	# gamma is a scale parameter that determines the scaling of SD to cell size#
	#########################################	#
		#X_Dist <- 360 #distance in km#
		#Y_Dist <- 360 #distance in km#
#
		setwd(paste(CodeDir,"/Demographies", sep=""))#
		DemogFileMeta <- paste(DemogFile,"Metadata")#
					a<-getDemogParams(DemogFileMeta)	#
					X_Dist <- a$X_Dist#
					Y_Dist <- a$Y_Dist#
					Gamma <- a$Gamma#
					SD <- a$SD#
					X_Demes <-	a$X_Demes#
					Y_Demes <- a$Y_Demes#
#
#
#
			CellSize <- SD*Gamma					#
			X_Dist_Adj <- X_Demes*CellSize#
			Y_Dist_Adj <- Y_Demes*CellSize#
#
		#
		X_Locs <- seq(0,X_Dist_Adj, by=CellSize)#
		Y_Locs <- seq(0,Y_Dist_Adj, by=CellSize)#
		AlleeDensity <- 2#
		#
		#
	##########################################
	#INput Environment#
	#########################################	#
	Envi <- GetEnvi(ENVI_ID, ENVI_DIR)#
	Envi_VECT = as.vector(Envi)#
			#
		if(dim(Envi)[1]!=X_Demes){print("Environment Matrix not same size as Landscape (x)")}#
		if(dim(Envi)[2]!=Y_Demes){print("Environment Matrix not same size as Landscape (y)")}#
	#
	##########################################
	#Input relationship between selection and environment#
	#make selection matrix and write to file#
	#########################################	#
	s_VECT <- Get_selVECT(s_low, s_high, Envi_VECT)		#selection matrix#
	t_VECT <- Get_selVECT(t_low,t_high, Envi_VECT)#
	#
	##########################################
	#Write selection matrix to file#
	#########################################	#
	write(as.vector(s_VECT), file = paste(runname, "SelectionMatrix", sep=""), ncol=Y_Demes)#
  #      pdf(file=paste(runname,"SelectionLandscape_Envi",ENVI_ID,".pdf",sep=""), width=6, height=6)#
#image.plot(X_Locs,Y_Locs, s_MAT, main=paste(ENVI_ID, ", s_low=",s_low, " ,s_high=", s_high, ", h=", h, sep=""), cex.main=0.7,breaks=seq(-0.1,0.1,0.001), col=two.colors(n=200, start="darkred", end="darkgreen", middle="white", alpha=1.0)#
#)	#
 #   dev.off()#
	#
#
#
	##########################################
	#Get initial population locations from Demography File#
	#########################################	#
		InitialPopVect <- as.integer(scan(DemogFile, what="integer", skip=0, nlines=1, quiet=T))#
#will need to adjust skip#
		InitialPopMat <- matrix(InitialPopVect, nrow= X_Demes, ncol=Y_Demes)#
#check byrow#
		#InitialPopMat[InitialPopMat==0]=NA#
		OccupiedCells <- InitialPopVect#
		OccupiedCells[which(InitialPopVect>0)]=1	#
		OccupiedCellsMat <- matrix(OccupiedCells, nrow= X_Demes, ncol=Y_Demes)#
		OccupiedNAMat <- OccupiedCellsMat#
		OccupiedNAMat[OccupiedCellsMat==0]=NA#
#
	##########################################
	#Make a square grid for a metapopulation#
	#########################################			#
	vectorsize<- X_Demes*Y_Demes#
	OccupiedVect <- as.vector(OccupiedCellsMat)#
		x11P_freqVECT <- rep(0.25, vectorsize)*OccupiedVect #
		x12P_freqVECT <- rep(0.25, vectorsize)*OccupiedVect #
		x21P_freqVECT <- rep(0.25, vectorsize)*OccupiedVect #
		x22P_freqVECT <- rep(0.25, vectorsize)*OccupiedVect #
					#matrix of freq of p allele at time t#
			#only occupied cells have an allele frequency#
		#
	##########################################
	#Calculate scale for migration computations#
	#The scale is necessary because pops at the edges of space do not receive migrants from all other populations#
	#########################################	#
		P_scaleVECT <- as.vector(MigTrans0_75(OccupiedCellsMat)*OccupiedCellsMat)#
			# in the first 100-1000 generations, we let the population evolve without growing (ie there is a glacier)#
			# when we remove the barrier to population growth, the above code will change#
		#
#
	#
	##########################################
	#Print Run Metadata#
	#########################################	#
	setwd(paste(headDir,subfolder,sep=""))#
		Metadatafile <- paste(runname,"Demography_Metadata",sep="")#
		write(runname, file= Metadatafile) #
		write(paste("Demography file = ", DemogFile), file=Metadatafile, append=TRUE)#
		write(paste("Landscape Size (km)= ", X_Dist, Y_Dist ), file=Metadatafile, append=TRUE)#
		write(paste("Adjusted Landscape Size (km) = ", X_Dist_Adj, Y_Dist_Adj), file=Metadatafile, append=TRUE)#
		write(paste("Gamma = ", Gamma), file=Metadatafile, append=TRUE)#
		write(paste("SD=",SD), file=Metadatafile, append=TRUE)#
		write(paste("Cell Size (km)=",CellSize), file=Metadatafile, append=TRUE)#
		write(paste("Grid Size = ", X_Demes, Y_Demes), file=Metadatafile, append=TRUE)#
		write(paste("Mutation Rate = ", u), file=Metadatafile, append=TRUE)	#
		write(paste("K Per Cell = ", K_cell), file=Metadatafile, append=TRUE)	#
		write(paste("r = ", r), file=Metadatafile, append=TRUE)#
		write(paste("NumOfStartingGenerations=", START_GEN), file=Metadatafile, append=TRUE)#
		write(paste("NumOfStartingGenerations=", START_GEN), file=Metadatafile, append=TRUE)#
		write(paste("ENVI_ID",	ENVI_ID),file=Metadatafile, append=TRUE)#
		write(paste("s_low",	s_low),file=Metadatafile, append=TRUE)#
		write(paste("s_high",	s_high),file=Metadatafile, append=TRUE)#
		write(paste("t_low",	t_low),file=Metadatafile, append=TRUE)#
		write(paste("t_high",	t_high),file=Metadatafile, append=TRUE)#
		write(paste("recombination",	recomb),file=Metadatafile, append=TRUE)#
		write(paste("RefugiaSelection",	RefugiaSelection),file=Metadatafile, append=TRUE)#
		write(paste("Post-RefugeGeneration", "FST_All"), file=Metadatafile, append=TRUE)#
		#
	##########################################
	# Loop for 1000 generations and let evolution happen in the refugia with no pop growth#
	##########################################		#
##############################################################################
	for (gen in 1:START_GEN){#
#
		#############################################################
		#Step 1: Mutation#
		#############################################################
	#
		mVECT <- TwoLocusMutation(x11P_freqVECT, x12P_freqVECT, x21P_freqVECT, x22P_freqVECT, u, OccupiedVect)#
	#
		#############################################################
		#Step 2: Recombination#
		#############################################################
		rVECT <- TwoLocusRecombination(mVECT$x11mut, mVECT$x12mut, mVECT$x21mut, mVECT$x22mut, recomb, OccupiedVect)#
		#
		#############################################################
		#Step 3: Selection#
		#############################################################
		if (RefugiaSelection==TRUE){#
			#
			selVECT <- TwoLocusSelection(rVECT$x11r, rVECT$x12r, rVECT$x21r, rVECT$x22r, s_VECT, t_VECT, OccupiedVect)#
			#
		}else{selVECT<- rVECT; names(selVECT)<-c("x11s", "x12s", "x21s", "x22s")}#
		#
		#
		#############################################################
		#Step 4: Dispersal/migration#
		#############################################################
		#In this case, the occupied cells aren't changing between generations#
		#Once we start letting the population grow, the code below will be a bit different#
		#
		VECT <- TwoLocusMigration(selVECT$x11s, selVECT$x12s, selVECT$x21s, selVECT$x22s, OccupiedVect,P_scaleVECT, X_Demes, Y_Demes)		#
		#gives VECT$x11mig etc.#
		#
		 #############################################################
        #Step 5: Drift#
        #############################################################
        DriftMat <- TwoLocusDrift(VECT$x11mig, VECT$x12mig, VECT$x21mig, VECT$x22mig, InitialPopVect)#
       	x11P_freqVECT <- DriftMat[1,]#
       	x12P_freqVECT <- DriftMat[2,]#
       	x21P_freqVECT <- DriftMat[3,]#
       	x22P_freqVECT <- DriftMat[4,]#
						#
		if(gen%%100==0){print(c("Isolation generation",gen))}#
	}#end first set of generation loops	#
##############################################################################
#
#
	#
	#P_plotMAT = P_migMAT#
	#P_plotMAT[OccupiedCellsMat==0]=NA#
	#N_plotMAT = InitialPopMat#
	#N_plotMAT[OccupiedCellsMat==0]=NA	#
#
		if(MOVIE==TRUE){	#
			MovieDirname <- paste(headDir,subfolder,"/", runname,"Movie",sep="")#
			dir.create(MovieDirname)#
			setwd(MovieDirname)#
			#	pdf(file=paste(runname,"Image_1",".pdf",sep=""), width=12, height=6)#
#
			#		par(mfrow=c(1,2), mar=c(2,2,0,0))#
			#		image.plot(P_plotMAT, main=paste("Allele freqs after" ,START_GEN, "gens of isolation"), breaks=seq(0,1,0.01), col=two.colors(n=100, start="darkblue", end="darkred", middle=grey(0.8), alpha=1.0),cex.main=0.8)	#
			#		image.plot(N_plotMAT, main=paste("Local Density after" ,START_GEN, "gens of isolation"), breaks=seq(1,K_cell+10,1), col=tim.colors(K_cell+9), cex.main=0.8)#
			#	dev.off()#
			}#
	#
		PopMat2<-InitialPopMat#
		AtEQ <- FALSE#
		EqGen<-NA#
##############################################################################
	for (gen in 1:GEN){#
		#
		if (sum(is.na(PopMat2))>0){break;}#
		#############################################################
		#Step: Get Demography: Population abundances in next generation (start next generation)#
		#############################################################
		if (AtEQ==FALSE){#
			Last_PopMat <- PopMat2#
			#
			Fecundity_Mat <- PopMat2 + r*PopMat2*(K_cell-PopMat2)/K_cell #logistic#
			#
			PopMat <- MigTrans0_75(Fecundity_Mat)	#this is the next generation#
#
			PopMat[PopMat<AlleeDensity]=0	#
			if(sum(PopMat)==0){print("Sorry you went extinct!"); break;}#
			#
			OccupiedCellsMat <- PopMat#
			OccupiedCellsMat[PopMat>0]=1	 #These cells are occupied in this time step#
					#
			if(gen>100 & sum(Last_PopMat==round(PopMat))==(X_Demes*Y_Demes) & AtEQ == FALSE){AtEQ=TRUE; EqGen=gen; print(c("Eq has been reached at gen =", gen))} #if at equilibrium, tell it#
		}#
		if (AtEQ==TRUE & gen==(EqGen+1)){#
			Fecundity_Mat <- PopMat + r*PopMat*(K_cell-PopMat)/K_cell #
			PopMat <- MigTrans0_75(Fecundity_Mat)#
			}#end if#
		#
		PopMat2 <- round(PopMat)			# round pop mat#
		OccupiedVect <- as.vector(OccupiedCellsMat)#
		FecundityVect <- as.vector(Fecundity_Mat)#
		#
		#############################################################
		#Step 1: Mutation#
		#############################################################
	#
		mVECT <- TwoLocusMutation(x11P_freqVECT, x12P_freqVECT, x21P_freqVECT, x22P_freqVECT, u, OccupiedVect)#
	#
		#############################################################
		#Step 2: Recombination#
		#############################################################
		rVECT <- TwoLocusRecombination(mVECT$x11mut, mVECT$x12mut, mVECT$x21mut, mVECT$x22mut, recomb, OccupiedVect)#
		#
		#############################################################
		#Step 3: Selection#
		############################################################	#
			selVECT <- TwoLocusSelection(rVECT$x11r, rVECT$x12r, rVECT$x21r, rVECT$x22r, s_VECT, t_VECT, OccupiedVect)#
		#
		#
		#############################################################
		#Step 4: Dispersal/migration#
		#############################################################
		#In this case, the occupied cells aren't changing between generations#
		#Once we start letting the population grow, the code below will be a bit different#
		#
		VECT <- TwoLocusMigration(selVECT$x11s*FecundityVect, selVECT$x12s*FecundityVect, selVECT$x21s*FecundityVect, selVECT$x22s*FecundityVect, OccupiedVect, as.vector(PopMat), X_Demes, Y_Demes)		#
		#gives VECT$x11mig etc.#
		#P_migMAT <- MigTrans0_75(P_freqMAT*Fecundity_Mat)#
		#P_migMAT[OccupiedCellsMat==0] = 0 		#
		#P_migMAT[OccupiedCellsMat>0] = P_migMAT[OccupiedCellsMat>0]/PopMat[OccupiedCellsMat>0]#
		#
		 #############################################################
        #Step 5: Drift#
        #############################################################
        DriftMat <- TwoLocusDrift(VECT$x11mig, VECT$x12mig, VECT$x21mig, VECT$x22mig, as.vector(PopMat2))#
       	x11P_freqVECT <- DriftMat[1,]#
       	x12P_freqVECT <- DriftMat[2,]#
       	x21P_freqVECT <- DriftMat[3,]#
       	x22P_freqVECT <- DriftMat[4,]#
						#
		#
		#############################################################
		#Step -e-:Output every x gens#
		#############################################################
#
		if (gen%%20==0){#
			#Sampling occurs after migration (drift tends to fix alleles at the edges)#
													#make a movie frame every 10 gens#
			setwd(paste(headDir,subfolder,sep=""))#
			FST_x11<- WC_FST_LargeSample(VECT$x11mig[OccupiedVect==1])#
			FST_x12 <- WC_FST_LargeSample(VECT$x12mig[OccupiedVect==1])#
			FST_x21 <- WC_FST_LargeSample(VECT$x21mig[OccupiedVect==1])#
			FST_x22 <- WC_FST_LargeSample(VECT$x22mig[OccupiedVect==1])#
			FST_All <- c(FST_x11, FST_x12, FST_x21, FST_x22)#
			#
			#print(paste(gen, runname, FST_All, sep=" "))	 		#
			write(c(gen, FST_All), file=Metadatafile, append=TRUE, ncol=5)#
#
#
			############## Write FST through time to a file ##############
			setwd(headDir)	#
			fst_out = c(runname, gen, FST_All, r, K_cell, "\n")#
			write(fst_out, ResultsFSTFile, append=TRUE, ncolumns=length(fst_out))#
			#
			############## produce maps every x=100 gens #############									#
			if(gen%%100==0 & MOVIE==TRUE){#
			#	P_plotMAT = P_migMAT#
			#	P_plotMAT[OccupiedCellsMat==0]=NA#
				N_plotMAT = PopMat2#
				N_plotMAT[OccupiedCellsMat==0]=NA#
		#
		#
					setwd(MovieDirname)#
			#	pdf(file=paste(runname,"Image_",gen,".pdf",sep=""), width=6, height=3)#
             #           par(mfrow=c(1,2), mar=c(2,2,2,0))#
              #          plotAlleleFreqImage(X_Locs, Y_Locs, P_plotMAT, gen, FST_All)#
               #         image.plot(X_Locs,Y_Locs, N_plotMAT, main=paste("Local Density:" ,gen, "gens"), breaks=seq(1,K_cell+10,1), col=tim.colors(K_cell+9), cex.main=0.9,cex.axis=0.6 )#
				#	dev.off()#
			} #end image plots#
				#
					#
			if(gen%%100==0){ 		#
				write(as.vector(VECT$x11mig), file=paste(runname,"Matrix_AlleleFreqs_x11_Gen",gen,sep=""), ncolumns=Y_Demes)	#
				write(as.vector(VECT$x12mig), file=paste(runname,"Matrix_AlleleFreqs_x12_Gen",gen,sep=""), ncolumns=Y_Demes)	#
				write(as.vector(VECT$x21mig), file=paste(runname,"Matrix_AlleleFreqs_x21_Gen",gen,sep=""), ncolumns=Y_Demes)	#
				write(as.vector(VECT$x22mig), file=paste(runname,"Matrix_AlleleFreqs_x22_Gen",gen,sep=""), ncolumns=Y_Demes)#
				}#end matrix writing	#
		}#end 20 gens#
			#
#
	}#end generation loops	#
##############################################################################
	#
#
#
#
	##################################
	#Write final allele frequencies in each pop to a file in subdirectory "Neutral Landscapes Demog"#
	##################################
		setwd(paste(headDir,subfolder,sep=""))#
		N_Tot <- sum(PopMat)#
		DensityPerKM <- N_Tot/(X_Dist*Y_Dist)#
		K_eff <- max(PopMat)#
		N_Tot_Adj <- NA#
		NePerCell <- mean(PopMat)#
		#
		#write(as.vector(P_migMAT), file=paste(runname,"Matrix_AlleleFreqs",sep=""), ncolumns=Y_Demes)#
			#if I write it as a matrix, it will be transposed when I try to upload it again!#
		#pdf(file=paste(runname,"Image",".pdf",sep=""), width=6, height=6, bg="white")#
         #   mar=c(2,2,2,0)#
          #  plotAlleleFreqImageDetailed(X_Locs, Y_Locs, P_plotMAT, gen, FST_All, SD, DensityPerKM, NePerCell)#
		#dev.off()#
		#
	##################################
	#Write time elapsed to metadata#
	#################################	#
			write(" ", file=Metadatafile, append=TRUE)#
			write(paste("Number generations elapsed =", gen), file=Metadatafile, append=TRUE)#
			write(paste("Generations until demographic Eq =", EqGen), file=Metadatafile, append=TRUE)#
			endT <- toc()#
			TotalT <- round(endT-startT)#
			write(paste("Time Elapsed (sec)",TotalT), file=Metadatafile, append=TRUE)#
	#
	##################################
	#Write main output to a file in main directory#
	#################################	#
		setwd(headDir)	#
#
		allVars <- c(runname, X_Dist, Y_Dist, X_Dist_Adj, Y_Dist_Adj, X_Demes,Y_Demes, Gamma, SD, CellSize, N_Tot, N_Tot_Adj, NePerCell, DensityPerKM, u, gen,  MOVIE, K_cell, K_eff, r, EqGen, ENVI_ID, s_low, s_high, t_low, t_high, recomb, RefugiaSelection, FST_All, "\n")#, TotalT)	#
		write(allVars, "Selected_DemogLandscapeRuns2.txt", append=TRUE, ncolumns=length(allVars))#
#
}#end function
source("Code_AllSourceFiles.R")
#
#
IBDSel_Demog <- function(DemogFile, START_GEN, GEN, r, K_cell, u, MOVIE, CodeDir, headDir, subfolder, ResultsFSTFile, ENVI_ID, ENVI_DIR, s_low, s_high, t_low, t_high, recomb, RefugiaSelection){#
	 #
	#	The Demog File has info on the starting locations of the population(s)#
	#	START_GEN = number of generations to loop through before population expansion#
	#	GEN = number of generations to loop through for population growth#
	#  r = growth rate#
	# K_cell = Carrying Capacity in each cell, K_cell = 43 will give ~1e07 individuals on a 360 * 360 landscape#
	# u = mutation rate#
	# MOVIE = TRUE, print out an image every 50 generations#
#
	#CodeDir <- ("~/Dropbox/MetapopCode") #other comps#
	#CodeDir <- "/home/klott/MetapopCode" # ROGUE#
	#setwd(CodeDir) #
	#headDir <- ("/home/klott/MetapopResults") # ROGUE#
		#
	  startT <- tic()#
#
	runname <- getRunName() #
#  subfolder <- "/NeutralLandscapesDemog"#
    #
    if (file.exists(paste(headDir, subfolder, sep=""))){}else{dir.create(paste(headDir, subfolder, sep=""))}#
	#
		#
	##########################################
	# Determine scaling for population based on dispersal kernel#
	# SD is sigma or the standard deviation of the dispersal kernel#
	# gamma is a scale parameter that determines the scaling of SD to cell size#
	#########################################	#
		#X_Dist <- 360 #distance in km#
		#Y_Dist <- 360 #distance in km#
#
		setwd(paste(CodeDir,"/Demographies", sep=""))#
		DemogFileMeta <- paste(DemogFile,"Metadata")#
					a<-getDemogParams(DemogFileMeta)	#
					X_Dist <- a$X_Dist#
					Y_Dist <- a$Y_Dist#
					Gamma <- a$Gamma#
					SD <- a$SD#
					X_Demes <-	a$X_Demes#
					Y_Demes <- a$Y_Demes#
#
#
#
			CellSize <- SD*Gamma					#
			X_Dist_Adj <- X_Demes*CellSize#
			Y_Dist_Adj <- Y_Demes*CellSize#
#
		#
		X_Locs <- seq(0,X_Dist_Adj, by=CellSize)#
		Y_Locs <- seq(0,Y_Dist_Adj, by=CellSize)#
		AlleeDensity <- 2#
		#
		#
	##########################################
	#INput Environment#
	#########################################	#
	Envi <- GetEnvi(ENVI_ID, ENVI_DIR)#
	Envi_VECT = as.vector(Envi)#
			#
		if(dim(Envi)[1]!=X_Demes){print("Environment Matrix not same size as Landscape (x)")}#
		if(dim(Envi)[2]!=Y_Demes){print("Environment Matrix not same size as Landscape (y)")}#
	#
	##########################################
	#Input relationship between selection and environment#
	#make selection matrix and write to file#
	#########################################	#
	s_VECT <- Get_selVECT(s_low, s_high, Envi_VECT)		#selection matrix#
	t_VECT <- Get_selVECT(t_low,t_high, Envi_VECT)#
	#
	##########################################
	#Write selection matrix to file#
	#########################################	#
	write(as.vector(s_VECT), file = paste(runname, "SelectionMatrix", sep=""), ncol=Y_Demes)#
  #      pdf(file=paste(runname,"SelectionLandscape_Envi",ENVI_ID,".pdf",sep=""), width=6, height=6)#
#image.plot(X_Locs,Y_Locs, s_MAT, main=paste(ENVI_ID, ", s_low=",s_low, " ,s_high=", s_high, ", h=", h, sep=""), cex.main=0.7,breaks=seq(-0.1,0.1,0.001), col=two.colors(n=200, start="darkred", end="darkgreen", middle="white", alpha=1.0)#
#)	#
 #   dev.off()#
	#
#
#
	##########################################
	#Get initial population locations from Demography File#
	#########################################	#
		InitialPopVect <- as.integer(scan(DemogFile, what="integer", skip=0, nlines=1, quiet=T))#
#will need to adjust skip#
		InitialPopMat <- matrix(InitialPopVect, nrow= X_Demes, ncol=Y_Demes)#
#check byrow#
		#InitialPopMat[InitialPopMat==0]=NA#
		OccupiedCells <- InitialPopVect#
		OccupiedCells[which(InitialPopVect>0)]=1	#
		OccupiedCellsMat <- matrix(OccupiedCells, nrow= X_Demes, ncol=Y_Demes)#
		OccupiedNAMat <- OccupiedCellsMat#
		OccupiedNAMat[OccupiedCellsMat==0]=NA#
#
	##########################################
	#Make a square grid for a metapopulation#
	#########################################			#
	vectorsize<- X_Demes*Y_Demes#
	OccupiedVect <- as.vector(OccupiedCellsMat)#
		x11P_freqVECT <- rep(0.25, vectorsize)*OccupiedVect #
		x12P_freqVECT <- rep(0.25, vectorsize)*OccupiedVect #
		x21P_freqVECT <- rep(0.25, vectorsize)*OccupiedVect #
		x22P_freqVECT <- rep(0.25, vectorsize)*OccupiedVect #
					#matrix of freq of p allele at time t#
			#only occupied cells have an allele frequency#
		#
	##########################################
	#Calculate scale for migration computations#
	#The scale is necessary because pops at the edges of space do not receive migrants from all other populations#
	#########################################	#
		P_scaleVECT <- as.vector(MigTrans0_75(OccupiedCellsMat)*OccupiedCellsMat)#
			# in the first 100-1000 generations, we let the population evolve without growing (ie there is a glacier)#
			# when we remove the barrier to population growth, the above code will change#
		#
#
	#
	##########################################
	#Print Run Metadata#
	#########################################	#
	setwd(paste(headDir,subfolder,sep=""))#
		Metadatafile <- paste(runname,"Demography_Metadata",sep="")#
		write(runname, file= Metadatafile) #
		write(paste("Demography file = ", DemogFile), file=Metadatafile, append=TRUE)#
		write(paste("Landscape Size (km)= ", X_Dist, Y_Dist ), file=Metadatafile, append=TRUE)#
		write(paste("Adjusted Landscape Size (km) = ", X_Dist_Adj, Y_Dist_Adj), file=Metadatafile, append=TRUE)#
		write(paste("Gamma = ", Gamma), file=Metadatafile, append=TRUE)#
		write(paste("SD=",SD), file=Metadatafile, append=TRUE)#
		write(paste("Cell Size (km)=",CellSize), file=Metadatafile, append=TRUE)#
		write(paste("Grid Size = ", X_Demes, Y_Demes), file=Metadatafile, append=TRUE)#
		write(paste("Mutation Rate = ", u), file=Metadatafile, append=TRUE)	#
		write(paste("K Per Cell = ", K_cell), file=Metadatafile, append=TRUE)	#
		write(paste("r = ", r), file=Metadatafile, append=TRUE)#
		write(paste("NumOfStartingGenerations=", START_GEN), file=Metadatafile, append=TRUE)#
		write(paste("NumOfStartingGenerations=", START_GEN), file=Metadatafile, append=TRUE)#
		write(paste("ENVI_ID",	ENVI_ID),file=Metadatafile, append=TRUE)#
		write(paste("s_low",	s_low),file=Metadatafile, append=TRUE)#
		write(paste("s_high",	s_high),file=Metadatafile, append=TRUE)#
		write(paste("t_low",	t_low),file=Metadatafile, append=TRUE)#
		write(paste("t_high",	t_high),file=Metadatafile, append=TRUE)#
		write(paste("recombination",	recomb),file=Metadatafile, append=TRUE)#
		write(paste("RefugiaSelection",	RefugiaSelection),file=Metadatafile, append=TRUE)#
		write(paste("Post-RefugeGeneration", "FST_All"), file=Metadatafile, append=TRUE)#
		#
	##########################################
	# Loop for 1000 generations and let evolution happen in the refugia with no pop growth#
	##########################################		#
##############################################################################
	for (gen in 1:START_GEN){#
#
		#############################################################
		#Step 1: Mutation#
		#############################################################
	#
		mVECT <- TwoLocusMutation(x11P_freqVECT, x12P_freqVECT, x21P_freqVECT, x22P_freqVECT, u, OccupiedVect)#
	#
		#############################################################
		#Step 2: Recombination#
		#############################################################
		rVECT <- TwoLocusRecombination(mVECT$x11mut, mVECT$x12mut, mVECT$x21mut, mVECT$x22mut, recomb, OccupiedVect)#
		#
		#############################################################
		#Step 3: Selection#
		#############################################################
		if (RefugiaSelection==TRUE){#
			#
			selVECT <- TwoLocusSelection(rVECT$x11r, rVECT$x12r, rVECT$x21r, rVECT$x22r, s_VECT, t_VECT, OccupiedVect)#
			#
		}else{selVECT<- rVECT; names(selVECT)<-c("x11s", "x12s", "x21s", "x22s")}#
		#
		#
		#############################################################
		#Step 4: Dispersal/migration#
		#############################################################
		#In this case, the occupied cells aren't changing between generations#
		#Once we start letting the population grow, the code below will be a bit different#
		#
		VECT <- TwoLocusMigration(selVECT$x11s, selVECT$x12s, selVECT$x21s, selVECT$x22s, OccupiedVect,P_scaleVECT, X_Demes, Y_Demes)		#
		#gives VECT$x11mig etc.#
		#
		 #############################################################
        #Step 5: Drift#
        #############################################################
        DriftMat <- TwoLocusDrift(VECT$x11mig, VECT$x12mig, VECT$x21mig, VECT$x22mig, InitialPopVect, OccupiedVect)#
       	x11P_freqVECT <- DriftMat[1,]#
       	x12P_freqVECT <- DriftMat[2,]#
       	x21P_freqVECT <- DriftMat[3,]#
       	x22P_freqVECT <- DriftMat[4,]#
						#
		if(gen%%100==0){print(c("Isolation generation",gen))}#
	}#end first set of generation loops	#
##############################################################################
#
#
	#
	#P_plotMAT = P_migMAT#
	#P_plotMAT[OccupiedCellsMat==0]=NA#
	#N_plotMAT = InitialPopMat#
	#N_plotMAT[OccupiedCellsMat==0]=NA	#
#
		if(MOVIE==TRUE){	#
			MovieDirname <- paste(headDir,subfolder,"/", runname,"Movie",sep="")#
			dir.create(MovieDirname)#
			setwd(MovieDirname)#
			#	pdf(file=paste(runname,"Image_1",".pdf",sep=""), width=12, height=6)#
#
			#		par(mfrow=c(1,2), mar=c(2,2,0,0))#
			#		image.plot(P_plotMAT, main=paste("Allele freqs after" ,START_GEN, "gens of isolation"), breaks=seq(0,1,0.01), col=two.colors(n=100, start="darkblue", end="darkred", middle=grey(0.8), alpha=1.0),cex.main=0.8)	#
			#		image.plot(N_plotMAT, main=paste("Local Density after" ,START_GEN, "gens of isolation"), breaks=seq(1,K_cell+10,1), col=tim.colors(K_cell+9), cex.main=0.8)#
			#	dev.off()#
			}#
	#
		PopMat2<-InitialPopMat#
		AtEQ <- FALSE#
		EqGen<-NA#
##############################################################################
	for (gen in 1:GEN){#
		#
		if (sum(is.na(PopMat2))>0){break;}#
		#############################################################
		#Step: Get Demography: Population abundances in next generation (start next generation)#
		#############################################################
		if (AtEQ==FALSE){#
			Last_PopMat <- PopMat2#
			#
			Fecundity_Mat <- PopMat2 + r*PopMat2*(K_cell-PopMat2)/K_cell #logistic#
			#
			PopMat <- MigTrans0_75(Fecundity_Mat)	#this is the next generation#
#
			PopMat[PopMat<AlleeDensity]=0	#
			if(sum(PopMat)==0){print("Sorry you went extinct!"); break;}#
			#
			OccupiedCellsMat <- PopMat#
			OccupiedCellsMat[PopMat>0]=1	 #These cells are occupied in this time step#
					#
			if(gen>100 & sum(Last_PopMat==round(PopMat))==(X_Demes*Y_Demes) & AtEQ == FALSE){AtEQ=TRUE; EqGen=gen; print(c("Eq has been reached at gen =", gen))} #if at equilibrium, tell it#
		}#
		if (AtEQ==TRUE & gen==(EqGen+1)){#
			Fecundity_Mat <- PopMat + r*PopMat*(K_cell-PopMat)/K_cell #
			PopMat <- MigTrans0_75(Fecundity_Mat)#
			}#end if#
		#
		PopMat2 <- round(PopMat)			# round pop mat#
		OccupiedVect <- as.vector(OccupiedCellsMat)#
		FecundityVect <- as.vector(Fecundity_Mat)#
		#
		#############################################################
		#Step 1: Mutation#
		#############################################################
	#
		mVECT <- TwoLocusMutation(x11P_freqVECT, x12P_freqVECT, x21P_freqVECT, x22P_freqVECT, u, OccupiedVect)#
	#
		#############################################################
		#Step 2: Recombination#
		#############################################################
		rVECT <- TwoLocusRecombination(mVECT$x11mut, mVECT$x12mut, mVECT$x21mut, mVECT$x22mut, recomb, OccupiedVect)#
		#
		#############################################################
		#Step 3: Selection#
		############################################################	#
			selVECT <- TwoLocusSelection(rVECT$x11r, rVECT$x12r, rVECT$x21r, rVECT$x22r, s_VECT, t_VECT, OccupiedVect)#
		#
		#
		#############################################################
		#Step 4: Dispersal/migration#
		#############################################################
		#In this case, the occupied cells aren't changing between generations#
		#Once we start letting the population grow, the code below will be a bit different#
		#
		VECT <- TwoLocusMigration(selVECT$x11s*FecundityVect, selVECT$x12s*FecundityVect, selVECT$x21s*FecundityVect, selVECT$x22s*FecundityVect, OccupiedVect, as.vector(PopMat), X_Demes, Y_Demes)		#
		#gives VECT$x11mig etc.#
		#P_migMAT <- MigTrans0_75(P_freqMAT*Fecundity_Mat)#
		#P_migMAT[OccupiedCellsMat==0] = 0 		#
		#P_migMAT[OccupiedCellsMat>0] = P_migMAT[OccupiedCellsMat>0]/PopMat[OccupiedCellsMat>0]#
		#
		 #############################################################
        #Step 5: Drift#
        #############################################################
        DriftMat <- TwoLocusDrift(VECT$x11mig, VECT$x12mig, VECT$x21mig, VECT$x22mig, as.vector(PopMat2), OccupiedVect)#
       	x11P_freqVECT <- DriftMat[1,]#
       	x12P_freqVECT <- DriftMat[2,]#
       	x21P_freqVECT <- DriftMat[3,]#
       	x22P_freqVECT <- DriftMat[4,]#
						#
		#
		#############################################################
		#Step -e-:Output every x gens#
		#############################################################
#
		if (gen%%20==0){#
			#Sampling occurs after migration (drift tends to fix alleles at the edges)#
													#make a movie frame every 10 gens#
			setwd(paste(headDir,subfolder,sep=""))#
			FST_x11<- WC_FST_LargeSample(VECT$x11mig[OccupiedVect==1])#
			FST_x12 <- WC_FST_LargeSample(VECT$x12mig[OccupiedVect==1])#
			FST_x21 <- WC_FST_LargeSample(VECT$x21mig[OccupiedVect==1])#
			FST_x22 <- WC_FST_LargeSample(VECT$x22mig[OccupiedVect==1])#
			FST_All <- c(FST_x11, FST_x12, FST_x21, FST_x22)#
			#
			#print(paste(gen, runname, FST_All, sep=" "))	 		#
			write(c(gen, FST_All), file=Metadatafile, append=TRUE, ncol=5)#
#
#
			############## Write FST through time to a file ##############
			setwd(headDir)	#
			fst_out = c(runname, gen, FST_All, r, K_cell, "\n")#
			write(fst_out, ResultsFSTFile, append=TRUE, ncolumns=length(fst_out))#
			#
			############## produce maps every x=100 gens #############									#
			if(gen%%100==0 & MOVIE==TRUE){#
			#	P_plotMAT = P_migMAT#
			#	P_plotMAT[OccupiedCellsMat==0]=NA#
				N_plotMAT = PopMat2#
				N_plotMAT[OccupiedCellsMat==0]=NA#
		#
		#
					setwd(MovieDirname)#
			#	pdf(file=paste(runname,"Image_",gen,".pdf",sep=""), width=6, height=3)#
             #           par(mfrow=c(1,2), mar=c(2,2,2,0))#
              #          plotAlleleFreqImage(X_Locs, Y_Locs, P_plotMAT, gen, FST_All)#
               #         image.plot(X_Locs,Y_Locs, N_plotMAT, main=paste("Local Density:" ,gen, "gens"), breaks=seq(1,K_cell+10,1), col=tim.colors(K_cell+9), cex.main=0.9,cex.axis=0.6 )#
				#	dev.off()#
			} #end image plots#
				#
					#
			if(gen%%100==0){ 		#
				write(as.vector(VECT$x11mig), file=paste(runname,"Matrix_AlleleFreqs_x11_Gen",gen,sep=""), ncolumns=Y_Demes)	#
				write(as.vector(VECT$x12mig), file=paste(runname,"Matrix_AlleleFreqs_x12_Gen",gen,sep=""), ncolumns=Y_Demes)	#
				write(as.vector(VECT$x21mig), file=paste(runname,"Matrix_AlleleFreqs_x21_Gen",gen,sep=""), ncolumns=Y_Demes)	#
				write(as.vector(VECT$x22mig), file=paste(runname,"Matrix_AlleleFreqs_x22_Gen",gen,sep=""), ncolumns=Y_Demes)#
				}#end matrix writing	#
		}#end 20 gens#
			#
#
	}#end generation loops	#
##############################################################################
	#
#
#
#
	##################################
	#Write final allele frequencies in each pop to a file in subdirectory "Neutral Landscapes Demog"#
	##################################
		setwd(paste(headDir,subfolder,sep=""))#
		N_Tot <- sum(PopMat)#
		DensityPerKM <- N_Tot/(X_Dist*Y_Dist)#
		K_eff <- max(PopMat)#
		N_Tot_Adj <- NA#
		NePerCell <- mean(PopMat)#
		#
		#write(as.vector(P_migMAT), file=paste(runname,"Matrix_AlleleFreqs",sep=""), ncolumns=Y_Demes)#
			#if I write it as a matrix, it will be transposed when I try to upload it again!#
		#pdf(file=paste(runname,"Image",".pdf",sep=""), width=6, height=6, bg="white")#
         #   mar=c(2,2,2,0)#
          #  plotAlleleFreqImageDetailed(X_Locs, Y_Locs, P_plotMAT, gen, FST_All, SD, DensityPerKM, NePerCell)#
		#dev.off()#
		#
	##################################
	#Write time elapsed to metadata#
	#################################	#
			write(" ", file=Metadatafile, append=TRUE)#
			write(paste("Number generations elapsed =", gen), file=Metadatafile, append=TRUE)#
			write(paste("Generations until demographic Eq =", EqGen), file=Metadatafile, append=TRUE)#
			endT <- toc()#
			TotalT <- round(endT-startT)#
			write(paste("Time Elapsed (sec)",TotalT), file=Metadatafile, append=TRUE)#
	#
	##################################
	#Write main output to a file in main directory#
	#################################	#
		setwd(headDir)	#
#
		allVars <- c(runname, X_Dist, Y_Dist, X_Dist_Adj, Y_Dist_Adj, X_Demes,Y_Demes, Gamma, SD, CellSize, N_Tot, N_Tot_Adj, NePerCell, DensityPerKM, u, gen,  MOVIE, K_cell, K_eff, r, EqGen, ENVI_ID, s_low, s_high, t_low, t_high, recomb, RefugiaSelection, FST_All, "\n")#, TotalT)	#
		write(allVars, "Selected_DemogLandscapeRuns2.txt", append=TRUE, ncolumns=length(allVars))#
#
}#end function
#
CodeDir <- "/Users/katie/Dropbox/MetapopWestgrid/MetapopCodeWestgrid"#
setwd(CodeDir)#
source("Code_AllSourceFiles.R")#
 headDir <-"~/Desktop/PrelimResults/"#
  ResultsFSTFile<-"ResultsFST.txt"#
  if (file.exists(headDir)){} else {dir.create(headDir)}#
   subfolder="yo"#
  #
 r_levels = 0.4 #
 #
 K_cell = 40#
 # 45 ~ 10 million#
 # 25 ~ 5.7 million#
 # 90 ~ 20.7 million#
 #
 DemogFile = "1343668901Demography" #
u=10e-07#
#
#
ENVI_DIR<-"/Users/katie/Dropbox/MetapopWestgrid/MetapopCodeWestgrid/Environments/"#
 ENVI_ID<-"1343165759_364"#
 s_low=-0.1#
 s_high=0.1#
 t_low=0#
 t_high=0#
 recomb=0.5#
 RefugiaSelection=TRUE#
 #
 START_GEN=10#
 GEN=10#
 #
 setwd(CodeDir)#
source("Code_AllSourceFiles.R")#
 IBDSel_Demog(DemogFile, START_GEN, GEN, r, K_cell, u, MOVIE, CodeDir, headDir, subfolder, ResultsFSTFile, ENVI_ID, ENVI_DIR, s_low, s_high, t_low, t_high, recomb, RefugiaSelection)
